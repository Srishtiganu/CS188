import { NextResponse } from "next/server"

export async function POST(req: Request) {
  try {
    console.log("API route called with placeholder response")

    // Parse the request to get the last message (just for logging)
    const { messages } = await req.json()
    const lastMessage = messages[messages.length - 1]
    console.log("Last message:", lastMessage.content)

    // Create a placeholder response
    const placeholderResponse = `This is a placeholder response to your question about the research paper.
    
I'm simulating what an AI assistant would say about this topic. In a real implementation, this would be generated by the Google Gemini model.

Your question was about: "${lastMessage.content.split(". ")[1] || lastMessage.content}"

Some key points about this paper might include:
- The main contribution appears to be a novel approach to the problem
- The equations represent mathematical formulations of the core concepts
- The authors compare their results with previous work in the field
- There are some limitations to the approach that are discussed in section 4
- Future work could extend this in several interesting directions

Would you like me to elaborate on any specific aspect of the paper?`

    // Create a ReadableStream that outputs the placeholder response with some delay
    const encoder = new TextEncoder()
    const stream = new ReadableStream({
      async start(controller) {
        // Split the response into chunks to simulate streaming
        const chunks = placeholderResponse.split(". ")

        for (const chunk of chunks) {
          // Add a small delay between chunks to simulate streaming
          await new Promise((resolve) => setTimeout(resolve, 100))

          // Format the chunk as an SSE message with the text-delta format
          const message = {
            type: "text-delta",
            text: chunk + ". ",
          }

          controller.enqueue(encoder.encode(`data: ${JSON.stringify(message)}\n\n`))
        }

        controller.enqueue(encoder.encode(`data: [DONE]\n\n`))
        controller.close()
      },
    })

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    })
  } catch (error) {
    console.error("Error in API route:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}
